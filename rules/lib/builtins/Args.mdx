---
title: 'Args'
---

# Args

{% dynamic setvar source_file "src/main/java/com/google/devtools/build/lib/starlarkbuildapi/CommandLineArgsApi.java" %}
{% include "\_buttons.html" %}
An object that encapsulates, in a memory-efficient way, the data needed to build part or all of a command line.

It often happens that an action requires a large command line containing values accumulated from transitive dependencies. For example, a linker command line might list every object file needed by all of the libraries being linked. It is best practice to store such transitive data in [`depset`](../builtins/depset.html)s, so that they can be shared by multiple targets. However, if the rule author had to convert these depsets into lists of strings in order to construct an action command line, it would defeat this memory-sharing optimization.

For this reason, the action-constructing functions accept `Args` objects in addition to strings. Each `Args` object represents a concatenation of strings and depsets, with optional transformations for manipulating the data. `Args` objects do not process the depsets they encapsulate until the execution phase, when it comes time to calculate the command line. This helps defer any expensive copying until after the analysis phase is complete. See the [Optimizing Performance](https://bazel.build/rules/performance) page for more information.

`Args` are constructed by calling [`ctx.actions.args()`](../builtins/actions.html#args). They can be passed as the `arguments` parameter of [`ctx.actions.run()`](../builtins/actions.html#run) or [`ctx.actions.run_shell()`](../builtins/actions.html#run_shell). Each mutation of an `Args` object appends values to the eventual command line.

The `map_each` feature allows you to customize how items are transformed into strings. If you do not provide a `map_each` function, the standard conversion is as follows:

- Values that are already strings are left as-is.
- [`File`](../builtins/File.html) objects are turned into their `File.path` values.
- [`Label`](../builtins/Label.html) objects are turned into a string representation that resolves back to the same object when resolved in the context of the main repository. If possible, the string representation uses the apparent name of a repository in favor of the repository's canonical name, which makes this representation suited for use in BUILD files. While the exact form of the representation is not guaranteed, typical examples are `//foo:bar`, `@repo//foo:bar` and `@@canonical_name+//foo:bar.bzl`.
- All other types are turned into strings in an *unspecified* manner. For this reason, you should avoid passing values that are not of string or `File` type to `add()`, and if you pass them to `add_all()` or `add_joined()` then you should provide a `map_each` function.

When using string formatting (`format`, `format_each`, and `format_joined` params of the `add*()` methods), the format template is interpreted in the same way as `%`-substitution on strings, except that the template must have exactly one substitution placeholder and it must be `%s`. Literal percents may be escaped as `%%`. Formatting is applied after the value is converted to a string as per the above.

Each of the `add*()` methods have an alternate form that accepts an extra positional parameter, an "arg name" string to insert before the rest of the arguments. For `add_all` and `add_joined` the extra string will not be added if the sequence turns out to be empty. For instance, the same usage can add either `--foo val1 val2 val3 --bar` or just `--bar` to the command line, depending on whether the given sequence contains `val1..val3` or is empty.

If the size of the command line can grow longer than the maximum size allowed by the system, the arguments can be spilled over into parameter files. See [`use_param_file()`](#use_param_file) and [`set_param_file_format()`](#set_param_file_format).

Example: Suppose we wanted to generate the command line:


    --foo foo1.txt foo2.txt ... fooN.txt --bar bar1.txt,bar2.txt,...,barM.txt --baz

We could use the following `Args` object:

``` python

# foo_deps and bar_deps are depsets containing
# File objects for the foo and bar .txt files.
args = ctx.actions.args()
args.add_all("--foo", foo_deps)
args.add_joined("--bar", bar_deps, join_with=",")
args.add("--baz")
ctx.actions.run(
  ...
  arguments = [args],
  ...
)
```

## Members

- [add](#add)
- [add_all](#add_all)
- [add_joined](#add_joined)
- [set_param_file_format](#set_param_file_format)
- [use_param_file](#use_param_file)

## add

``` rule-signature
Args Args.add(arg_name_or_value, value=unbound, *, format=None)
```

Appends an argument to this command line.

### Parameters

<table class="table table-bordered table-condensed table-params">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td id="add.arg_name_or_value"><code>arg_name_or_value</code></td>
<td>required<br />
If two positional parameters are passed this is interpreted as the arg name. The arg name is added before the value without any processing. If only one positional parameter is passed, it is interpreted as <code>value</code> (see below).</td>
</tr>
<tr>
<td id="add.value"><code>value</code></td>
<td>default is <code>unbound</code><br />
The object to append. It will be converted to a string using the standard conversion mentioned above. Since there is no <code>map_each</code> parameter for this function, <code>value</code> should be either a string or a <code>File</code>. A list, tuple, depset, or directory <code>File</code> must be passed to <a href="#add_all"><code>add_all()</code> or</a> <a href="#add_joined"><code>add_joined()</code></a> instead of this method.</td>
</tr>
<tr>
<td id="add.format"><code>format</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
A format string pattern, to be applied to the stringified version of <code>value</code>.</td>
</tr>
</tbody>
</table>

## add_all

``` rule-signature
Args Args.add_all(arg_name_or_values, values=unbound, *, map_each=None, format_each=None, before_each=None, omit_if_empty=True, uniquify=False, expand_directories=True, terminate_with=None, allow_closure=False)
```

Appends multiple arguments to this command line. The items are processed lazily during the execution phase.

Most of the processing occurs over a list of arguments to be appended, as per the following steps:

1.  Each directory `File` item is replaced by all `File`s recursively contained in that directory.
2.  If `map_each` is given, it is applied to each item, and the resulting lists of strings are concatenated to form the initial argument list. Otherwise, the initial argument list is the result of applying the standard conversion to each item.
3.  Each argument in the list is formatted with `format_each`, if present.
4.  If `uniquify` is true, duplicate arguments are removed. The first occurrence is the one that remains.
5.  If a `before_each` string is given, it is inserted as a new argument before each existing argument in the list. This effectively doubles the number of arguments to be appended by this point.
6.  Except in the case that the list is empty and `omit_if_empty` is true (the default), the arg name and `terminate_with` are inserted as the first and last arguments, respectively, if they are given.

Note that empty strings are valid arguments that are subject to all these processing steps.

### Parameters

<table class="table table-bordered table-condensed table-params">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td id="add_all.arg_name_or_values"><code>arg_name_or_values</code></td>
<td>required<br />
If two positional parameters are passed this is interpreted as the arg name. The arg name is added before the <code>values</code> as a separate argument without any processing. This arg name will not be added if <code>omit_if_empty</code> is true (the default) and no other items are appended (as happens if <code>values</code> is empty or all of its items are filtered). If only one positional parameter is passed, it is interpreted as <code>values</code> (see below).</td>
</tr>
<tr>
<td id="add_all.values"><code>values</code></td>
<td><a href="../core/list.html" class="anchor">sequence</a>; or <a href="../builtins/depset.html" class="anchor">depset</a>;
default is <code>unbound</code><br />
The list, tuple, or depset whose items will be appended.</td>
</tr>
<tr>
<td id="add_all.map_each"><code>map_each</code></td>
<td>callable; or <code>None</code>;
default is <code>None</code><br />
A function that converts each item to zero or more strings, which may be further processed before appending. If this param is not provided, the standard conversion is used.
<p>The function is passed either one or two positional arguments: the item to convert, followed by an optional <a href="../builtins/DirectoryExpander.html"><code>DirectoryExpander</code></a>. The second argument will be passed only if the supplied function is user-defined (not built-in) and declares more than one parameter.</p>
<p>The return value's type depends on how many arguments are to be produced for the item:</p>
<ul>
<li>In the common case when each item turns into one string, the function should return that string.</li>
<li>If the item is to be filtered out entirely, the function should return <code>None</code>.</li>
<li>If the item turns into multiple strings, the function returns a list of those strings.</li>
</ul>
Returning a single string or <code>None</code> has the same effect as returning a list of length 1 or length 0 respectively. However, it is more efficient and readable to avoid creating a list where it is not needed.
<p>Ordinarily, items that are directories are automatically expanded to their contents when <code>expand_directories=True</code> is set. However, this will not expand directories contained inside other values -- for instance, when the items are structs that have directories as fields. In this situation, the <code>DirectoryExpander</code> argument can be applied to manually obtain the files of a given directory.</p>
<p>To avoid unintended retention of large analysis-phase data structures into the execution phase, the <code>map_each</code> function must be declared by a top-level <code>def</code> statement; it may not be a nested function closure by default.</p>
<p><em>Warning:</em> <a href="../globals/all.html#print"><code>print()</code></a> statements that are executed during the call to <code>map_each</code> will not produce any visible output.</p></td>
</tr>
<tr>
<td id="add_all.format_each"><code>format_each</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
An optional format string pattern, applied to each string returned by the <code>map_each</code> function. The format string must have exactly one '%s' placeholder.</td>
</tr>
<tr>
<td id="add_all.before_each"><code>before_each</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
An optional argument to append before each argument derived from <code>values</code> is appended.</td>
</tr>
<tr>
<td id="add_all.omit_if_empty"><code>omit_if_empty</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>True</code><br />
If true, if there are no arguments derived from <code>values</code> to be appended, then all further processing is suppressed and the command line will be unchanged. If false, the arg name and <code>terminate_with</code>, if provided, will still be appended regardless of whether or not there are other arguments.</td>
</tr>
<tr>
<td id="add_all.uniquify"><code>uniquify</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>False</code><br />
If true, duplicate arguments that are derived from <code>values</code> will be omitted. Only the first occurrence of each argument will remain. Usually this feature is not needed because depsets already omit duplicates, but it can be useful if <code>map_each</code> emits the same string for multiple items.</td>
</tr>
<tr>
<td id="add_all.expand_directories"><code>expand_directories</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>True</code><br />
If true, any directories in <code>values</code> will be expanded to a flat list of files. This happens before <code>map_each</code> is applied.</td>
</tr>
<tr>
<td id="add_all.terminate_with"><code>terminate_with</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
An optional argument to append after all other arguments. This argument will not be added if <code>omit_if_empty</code> is true (the default) and no other items are appended (as happens if <code>values</code> is empty or all of its items are filtered).</td>
</tr>
<tr>
<td id="add_all.allow_closure"><code>allow_closure</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>False</code><br />
If true, allows the use of closures in function parameters like <code>map_each</code>. Usually this isn't necessary and it risks retaining large analysis-phase data structures into the execution phase.</td>
</tr>
</tbody>
</table>

## add_joined

``` rule-signature
Args Args.add_joined(arg_name_or_values, values=unbound, *, join_with, map_each=None, format_each=None, format_joined=None, omit_if_empty=True, uniquify=False, expand_directories=True, allow_closure=False)
```

Appends an argument to this command line by concatenating together multiple values using a separator. The items are processed lazily during the execution phase.

Processing is similar to [`add_all()`](#add_all), but the list of arguments derived from `values` is combined into a single argument as if by `join_with.join(...)`, and then formatted using the given `format_joined` string template. Unlike `add_all()`, there is no `before_each` or `terminate_with` parameter since these are not generally useful when the items are combined into a single argument.

If after filtering there are no strings to join into an argument, and if `omit_if_empty` is true (the default), no processing is done. Otherwise if there are no strings to join but `omit_if_empty` is false, the joined string will be an empty string.

### Parameters

<table class="table table-bordered table-condensed table-params">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td id="add_joined.arg_name_or_values"><code>arg_name_or_values</code></td>
<td>required<br />
If two positional parameters are passed this is interpreted as the arg name. The arg name is added before <code>values</code> without any processing. This arg will not be added if <code>omit_if_empty</code> is true (the default) and there are no strings derived from <code>values</code> to join together (which can happen if <code>values</code> is empty or all of its items are filtered). If only one positional parameter is passed, it is interpreted as <code>values</code> (see below).</td>
</tr>
<tr>
<td id="add_joined.values"><code>values</code></td>
<td><a href="../core/list.html" class="anchor">sequence</a>; or <a href="../builtins/depset.html" class="anchor">depset</a>;
default is <code>unbound</code><br />
The list, tuple, or depset whose items will be joined.</td>
</tr>
<tr>
<td id="add_joined.join_with"><code>join_with</code></td>
<td><a href="../core/string.html" class="anchor">string</a>;
required<br />
A delimiter string used to join together the strings obtained from applying <code>map_each</code> and <code>format_each</code>, in the same manner as <a href="../core/string.html#join"><code>string.join()</code></a>.</td>
</tr>
<tr>
<td id="add_joined.map_each"><code>map_each</code></td>
<td>callable; or <code>None</code>;
default is <code>None</code><br />
Same as for <a href="#add_all.map_each"><code>add_all</code></a>.</td>
</tr>
<tr>
<td id="add_joined.format_each"><code>format_each</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
Same as for <a href="#add_all.format_each"><code>add_all</code></a>.</td>
</tr>
<tr>
<td id="add_joined.format_joined"><code>format_joined</code></td>
<td><a href="../core/string.html" class="anchor">string</a>; or <code>None</code>;
default is <code>None</code><br />
An optional format string pattern applied to the joined string. The format string must have exactly one '%s' placeholder.</td>
</tr>
<tr>
<td id="add_joined.omit_if_empty"><code>omit_if_empty</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>True</code><br />
If true, if there are no strings to join together (either because <code>values</code> is empty or all its items are filtered), then all further processing is suppressed and the command line will be unchanged. If false, then even if there are no strings to join together, two arguments will be appended: the arg name followed by an empty string (which is the logical join of zero strings).</td>
</tr>
<tr>
<td id="add_joined.uniquify"><code>uniquify</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>False</code><br />
Same as for <a href="#add_all.uniquify"><code>add_all</code></a>.</td>
</tr>
<tr>
<td id="add_joined.expand_directories"><code>expand_directories</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>True</code><br />
Same as for <a href="#add_all.expand_directories"><code>add_all</code></a>.</td>
</tr>
<tr>
<td id="add_joined.allow_closure"><code>allow_closure</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>False</code><br />
Same as for <a href="#add_all.allow_closure"><code>add_all</code></a>.</td>
</tr>
</tbody>
</table>

## set_param_file_format

``` rule-signature
Args Args.set_param_file_format(format)
```

Sets the format of the param file, if one is used

### Parameters

<table class="table table-bordered table-condensed table-params">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td id="set_param_file_format.format"><code>format</code></td>
<td><a href="../core/string.html" class="anchor">string</a>;
required<br />
Must be one of:
<ul>
<li>"multiline": Each item (argument name or value) is written verbatim to the param file with a newline character following it.</li>
<li>"shell": Same as "multiline", but the items are shell-quoted</li>
<li>"flag_per_line": Same as "multiline", but (1) only flags (beginning with '--') are written to the param file, and (2) the values of the flags, if any, are written on the same line with a '=' separator. This is the format expected by the Abseil flags library.</li>
</ul>
<p>The format defaults to "shell" if not called.</p></td>
</tr>
</tbody>
</table>

## use_param_file

``` rule-signature
Args Args.use_param_file(param_file_arg, *, use_always=False)
```

Spills the args to a params file, replacing them with a pointer to the param file. Use when your args may be too large for the system's command length limits.

Bazel may choose to elide writing the params file to the output tree during execution for efficiency. If you are debugging actions and want to inspect the param file, pass `--materialize_param_files` to your build.

### Parameters

<table class="table table-bordered table-condensed table-params">
<thead>
<tr>
<th>Parameter</th>
<th>Description</th>
</tr>
</thead>
<tbody>
<tr>
<td id="use_param_file.param_file_arg"><code>param_file_arg</code></td>
<td><a href="../core/string.html" class="anchor">string</a>;
required<br />
A format string with a single "%s". If the args are spilled to a params file then they are replaced with an argument consisting of this string formatted with the path of the params file.
<p>For example, if the args are spilled to a params file "params.txt", then specifying "--file=%s" would cause the action command line to contain "--file=params.txt".</p></td>
</tr>
<tr>
<td id="use_param_file.use_always"><code>use_always</code></td>
<td><a href="../core/bool.html" class="anchor">bool</a>;
default is <code>False</code><br />
Whether to always spill the args to a params file. If false, bazel will decide whether the arguments need to be spilled based on your system and arg length.</td>
</tr>
</tbody>
</table>
